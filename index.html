<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>mentat</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container">
    <nav class="nav-icons">
      <a href="stats.html" title="Stats">▦</a>
      <a href="settings.html" title="Settings">⚙</a>
    </nav>
    <h1>mentat</h1>
    <div class="divider"><div id="timer-progress" class="timer-progress"></div></div>

    <div id="start-screen">
      <p>Solve as many problems as you can in 1 minute.</p>
      <p class="level">Level: <span id="current-level">1</span> <span id="level-delta"></span></p>
      <p id="last-score" class="last-score hidden">Last score: <span id="last-score-value">0</span> <span id="stats-icon" class="stats-icon" onclick="toggleStatsPopup()">▦</span></p>
      <div id="stats-popup" class="stats-popup hidden">
        <div class="popup-header">Response Times <span class="popup-close" onclick="toggleStatsPopup()">×</span></div>
        <pre id="stats-chart"></pre>
      </div>
      <p class="high-score">High score: <span id="high-score-value">0</span></p>
      <button onclick="startGame()">Start</button>
      <p class="mantra">it is by will alone i set my mind in motion</p>
    </div>

    <div id="game-screen" class="hidden">
      <div class="problem"><span id="problem-text">0 + 0</span> = ?</div>
      <input type="text" id="answer" inputmode="numeric" autofocus oninput="checkAnswer()" onkeydown="handleKeyBinding(event)">
      <div class="score hidden">Score: <span id="score">0</span></div>
      <div id="debug-panel" class="debug">
        <span class="debug-label">DEBUG</span>
        <div>Addition: <span id="debug-addition">1.0</span></div>
        <div>Subtraction: <span id="debug-subtraction">1.0</span></div>
        <div><span id="debug-delta"></span></div>
        <div id="debug-modifiers" class="debug-modifiers"></div>
        <div class="debug-controls">
          <label><input type="checkbox" id="debug-addition-enabled" checked> +</label>
          <label><input type="checkbox" id="debug-subtraction-enabled" checked> −</label>
        </div>
        <div class="debug-controls">
          <button onclick="adjustDifficulty(-1)" class="debug-btn">-1</button>
          <button onclick="adjustDifficulty(1)" class="debug-btn">+1</button>
          <button onclick="endGame()" class="debug-btn">End Game</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let score = 0;
    let timeLeft = 30;
    let timer = null;
    let numbers = [];
    let correctAnswer = 0;
    let currentOperation = '+';
    let additionDifficulty = parseFloat(localStorage.getItem('additionLevel')) || 1.0;
    let subtractionDifficulty = parseFloat(localStorage.getItem('subtractionLevel')) || 1.0;
    let topScores = JSON.parse(localStorage.getItem('topScores')) || [];
    let totalPuzzlesSolved = parseInt(localStorage.getItem('totalPuzzlesSolved')) || 0;
    let keyBindings = JSON.parse(localStorage.getItem('keyBindings')) || {};
    let startingAdditionDifficulty = additionDifficulty;
    let startingSubtractionDifficulty = subtractionDifficulty;
    let currentPuzzleDifficulty = 1.0;
    let isEasyProblem = false;
    let hardMultiplier = 1;
    let activeModifiers = [];
    let problemStartTime = 0;
    let DEBUG = localStorage.getItem('debugMode') === 'true';
    let gameResponseTimes = [];
    const TARGET_TIME = 4;
    const GAME_DURATION = 60;

    function handleKeyBinding(event) {
      const key = event.key.toLowerCase();
      if (keyBindings[key]) {
        event.preventDefault();
        const input = document.getElementById('answer');
        input.value += keyBindings[key];
        checkAnswer();
      }
    }

    function getAverageLevel() {
      return (additionDifficulty + subtractionDifficulty) / 2;
    }

    function getCurrentDifficulty() {
      return currentOperation === '+' ? additionDifficulty : subtractionDifficulty;
    }

    // Initialize level display
    updateLevelDisplay();
    updateHighScoreDisplay();

    function getHighScore() {
      return topScores.length > 0 ? topScores[0].score : 0;
    }

    function updateHighScoreDisplay() {
      document.getElementById('high-score-value').textContent = getHighScore();
    }

    function addScore(newScore) {
      topScores.push({ score: newScore, date: Date.now() });
      topScores.sort((a, b) => b.score - a.score);
      topScores = topScores.slice(0, 10);
      localStorage.setItem('topScores', JSON.stringify(topScores));
      updateHighScoreDisplay();
    }

    function startGame() {
      score = 0;
      timeLeft = 60;
      gameResponseTimes = [];
      startingAdditionDifficulty = additionDifficulty;
      startingSubtractionDifficulty = subtractionDifficulty;

      document.getElementById('start-screen').classList.add('hidden');
      document.getElementById('game-screen').classList.remove('hidden');

      document.getElementById('score').textContent = score;
      document.getElementById('timer-progress').style.transition = 'width 1s linear';
      updateTimerBar();

      // Debug panel visibility
      document.getElementById('debug-panel').classList.toggle('hidden', !DEBUG);
      updateDebug();

      generateProblem();
      document.getElementById('answer').focus();

      if (!DEBUG) {
        timer = setInterval(() => {
          timeLeft--;
          updateTimerBar();

          if (timeLeft <= 0) {
            endGame();
          }
        }, 1000);
      }
    }

    function generateProblem() {
      // Randomly pick operation (respecting debug filters)
      const addEnabled = !DEBUG || document.getElementById('debug-addition-enabled').checked;
      const subEnabled = !DEBUG || document.getElementById('debug-subtraction-enabled').checked;

      if (addEnabled && subEnabled) {
        currentOperation = Math.random() < 0.5 ? '+' : '-';
      } else if (addEnabled) {
        currentOperation = '+';
      } else if (subEnabled) {
        currentOperation = '-';
      } else {
        currentOperation = '+'; // fallback if both unchecked
      }
      const difficulty = getCurrentDifficulty();

      // Reset modifiers
      activeModifiers = [];

      // 10% chance of easy problem (half current difficulty)
      // 10% chance of hard problem (2-5x current difficulty) - mutually exclusive with easy
      isEasyProblem = Math.random() < 0.1;
      const isHardProblem = !isEasyProblem && Math.random() < 0.1;
      hardMultiplier = isHardProblem ? Math.floor(Math.random() * 4) + 2 : 1; // 2-5x

      if (isEasyProblem) {
        currentPuzzleDifficulty = Math.max(1, difficulty / 2);
        activeModifiers.push('easy');
      } else if (isHardProblem) {
        currentPuzzleDifficulty = difficulty * hardMultiplier;
        activeModifiers.push('hard ' + hardMultiplier + 'x');
      } else {
        currentPuzzleDifficulty = difficulty;
      }

      const minNum = 1 + Math.floor(currentPuzzleDifficulty);
      const maxNum = 5 + Math.floor(currentPuzzleDifficulty * 2);

      // Generate first number (scales with difficulty)
      let num1 = Math.floor(Math.random() * (maxNum - minNum + 1)) + minNum;

      // Second number has wider range (1 to max)
      let num2 = Math.floor(Math.random() * maxNum) + 1;

      numbers = [num1, num2];

      // 10% chance: three-number problem
      const isThreeNumber = Math.random() < 0.1;
      if (isThreeNumber) {
        const num3 = Math.floor(Math.random() * maxNum) + 1;
        numbers.push(num3);
        activeModifiers.push('3 nums');
      }

      if (currentOperation === '+') {
        // 10% chance: challenge multiplier (double one number)
        if (Math.random() < 0.1) {
          const idx = Math.floor(Math.random() * numbers.length);
          numbers[idx] = numbers[idx] * 2;
          activeModifiers.push('x2');
        }

        // 10% chance: round number anchor (replace one number with round number)
        if (Math.random() < 0.1) {
          const roundNumbers = [10, 20, 25, 50, 100].filter(n => n <= maxNum * 2);
          if (roundNumbers.length > 0) {
            const idx = Math.floor(Math.random() * numbers.length);
            numbers[idx] = roundNumbers[Math.floor(Math.random() * roundNumbers.length)];
            activeModifiers.push('round');
          }
        }

        correctAnswer = numbers.reduce((sum, n) => sum + n, 0);
        document.getElementById('problem-text').textContent = numbers.join(' + ');
      } else {
        // Subtraction: generate answer first, then construct problem
        // Answer scales similarly to addition results
        const targetAnswer = Math.floor(Math.random() * (maxNum * 2 - minNum + 1)) + minNum;

        // Generate the number we subtract
        num2 = Math.floor(Math.random() * maxNum) + 1;

        // Calculate num1 to produce the target answer
        num1 = targetAnswer + num2;

        numbers = [num1, num2];

        // 10% chance: challenge multiplier (double one number)
        if (Math.random() < 0.1) {
          const idx = Math.floor(Math.random() * numbers.length);
          numbers[idx] = numbers[idx] * 2;
          activeModifiers.push('x2');
        }

        // 10% chance: round number anchor
        if (Math.random() < 0.1) {
          const roundNumbers = [10, 20, 25, 50, 100].filter(n => n <= maxNum * 2);
          if (roundNumbers.length > 0) {
            const idx = Math.floor(Math.random() * numbers.length);
            numbers[idx] = roundNumbers[Math.floor(Math.random() * roundNumbers.length)];
            activeModifiers.push('round');
          }
        }

        // 10% chance: negative result
        const allowNegative = Math.random() < 0.1;
        const subtractTotal = numbers.slice(1).reduce((sum, n) => sum + n, 0);

        if (allowNegative) {
          activeModifiers.push('negative');
          // Ensure negative result
          if (numbers[0] >= subtractTotal) {
            numbers[0] = Math.max(1, subtractTotal - Math.floor(Math.random() * maxNum) - 1);
          }
        } else {
          // Ensure positive result
          if (numbers[0] <= subtractTotal) {
            numbers[0] = subtractTotal + Math.floor(Math.random() * maxNum) + 1;
          }
        }
        correctAnswer = numbers[0] - subtractTotal;
        document.getElementById('problem-text').textContent = numbers[0] + ' - ' + numbers.slice(1).join(' - ');
      }

      document.getElementById('answer').value = '';
      problemStartTime = Date.now();
      updateDebugModifiers();
    }

    function updateDebugModifiers() {
      if (!DEBUG) return;
      const el = document.getElementById('debug-modifiers');
      if (activeModifiers.length === 0) {
        el.textContent = '';
      } else {
        el.textContent = '[' + activeModifiers.join('] [') + ']';
      }
    }

    function checkAnswer() {
      const answer = parseInt(document.getElementById('answer').value);
      if (answer === correctAnswer) {
        const elapsed = (Date.now() - problemStartTime) / 1000;
        const difficulty = getCurrentDifficulty();
        const points = Math.floor(difficulty) * hardMultiplier;
        const puzzleText = document.getElementById('problem-text').textContent;
        gameResponseTimes.push({ time: elapsed, puzzle: puzzleText, points: points });

        // Smooth difficulty adjustment (target time scales with hard multiplier)
        const adjustedTargetTime = TARGET_TIME * hardMultiplier;
        const timeDelta = elapsed - adjustedTargetTime; // negative = fast, positive = slow
        const timeMultiplier = Math.max(-1, Math.min(1, -timeDelta / 3));
        let delta = 0.25 * timeMultiplier;

        // Easy problems never increase difficulty
        if (isEasyProblem && delta > 0) {
          delta = 0;
        }

        // Apply delta to correct difficulty
        if (currentOperation === '+') {
          additionDifficulty = Math.max(1.0, additionDifficulty + delta);
        } else {
          subtractionDifficulty = Math.max(1.0, subtractionDifficulty + delta);
        }
        updateDebug(delta);

        // Score based on difficulty (scaled by hard multiplier)
        score += points;
        document.getElementById('score').textContent = score;

        // Track total puzzles solved
        totalPuzzlesSolved++;

        generateProblem();
      }
    }

    let debugDeltaTimeout = null;

    function updateDebug(delta = null) {
      if (!DEBUG) return;
      document.getElementById('debug-addition').textContent = additionDifficulty.toFixed(1);
      document.getElementById('debug-subtraction').textContent = subtractionDifficulty.toFixed(1);

      if (delta !== null && delta !== 0) {
        const deltaEl = document.getElementById('debug-delta');
        const sign = delta > 0 ? '+' : '';
        deltaEl.textContent = '(' + currentOperation + ') ' + sign + delta.toFixed(2);
        deltaEl.classList.add('visible');

        clearTimeout(debugDeltaTimeout);
        debugDeltaTimeout = setTimeout(() => {
          deltaEl.classList.remove('visible');
        }, 800);
      }
    }

    function updateLevelDisplay() {
      document.getElementById('current-level').textContent = Math.floor(getAverageLevel());
    }

    function updateTimerBar() {
      const percentage = (timeLeft / GAME_DURATION) * 100;
      document.getElementById('timer-progress').style.width = percentage + '%';
    }

    function adjustDifficulty(amount) {
      if (currentOperation === '+') {
        additionDifficulty = Math.max(1.0, additionDifficulty + amount);
      } else {
        subtractionDifficulty = Math.max(1.0, subtractionDifficulty + amount);
      }
      updateDebug(amount);
      generateProblem();
      document.getElementById('answer').focus();
    }

    function endGame() {
      clearInterval(timer);
      localStorage.setItem('additionLevel', additionDifficulty.toFixed(2));
      localStorage.setItem('subtractionLevel', subtractionDifficulty.toFixed(2));
      updateLevelDisplay();

      // Show level change (whole numbers only, based on average)
      const oldLevel = Math.floor((startingAdditionDifficulty + startingSubtractionDifficulty) / 2);
      const newLevel = Math.floor(getAverageLevel());
      const levelDelta = newLevel - oldLevel;
      const deltaEl = document.getElementById('level-delta');
      if (levelDelta !== 0) {
        const sign = levelDelta > 0 ? '+' : '';
        deltaEl.textContent = sign + levelDelta;
        deltaEl.className = levelDelta > 0 ? 'delta-up' : 'delta-down';
      } else {
        deltaEl.textContent = '';
      }

      // Save stats
      localStorage.setItem('totalPuzzlesSolved', totalPuzzlesSolved);
      addScore(score);

      const timerEl = document.getElementById('timer-progress');
      timerEl.style.transition = 'none';
      timerEl.style.width = '100%';
      document.getElementById('game-screen').classList.add('hidden');
      document.getElementById('start-screen').classList.remove('hidden');
      document.getElementById('last-score-value').textContent = score;
      document.getElementById('last-score').classList.remove('hidden');
      renderStatsChart();
    }

    function toggleStatsPopup() {
      document.getElementById('stats-popup').classList.toggle('hidden');
    }

    function renderStatsChart() {
      const chart = document.getElementById('stats-chart');
      if (gameResponseTimes.length === 0) {
        chart.textContent = 'No data';
        return;
      }

      const times = gameResponseTimes.map(p => p.time);
      const maxTime = Math.max(...times);
      const barWidth = 20;
      const lines = gameResponseTimes.map((p, i) => {
        const width = Math.round((p.time / maxTime) * barWidth);
        const bar = '█'.repeat(width) + '░'.repeat(barWidth - width);
        const puzzle = p.puzzle.padEnd(15);
        return `${puzzle} ${bar} ${p.time.toFixed(1)}s  +${p.points}`;
      });

      // Add summary
      const totalPoints = gameResponseTimes.reduce((sum, p) => sum + p.points, 0);
      const avg = times.reduce((a, b) => a + b, 0) / times.length;
      const fast = times.filter(t => t <= TARGET_TIME).length;
      lines.push('');
      lines.push(`avg: ${avg.toFixed(1)}s | fast: ${fast}/${gameResponseTimes.length} | total: ${totalPoints} points`);

      chart.textContent = lines.join('\n');
    }
  </script>
</body>
</html>
